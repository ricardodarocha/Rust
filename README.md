# Rust

Um reposit√≥rio para estudar Rust do come√ßo  

üöÄ **Este reposit√≥rio est√° crescendo r√°pido**  

- [Configurar um Ambiente Rust](https://www.rust-lang.org/pt-BR/tools/install)  
- [Hello World](#primeiro-exerc√≠cio)  
- [Api](https://github.com/ricardodarocha/Rust/blob/main/3_api/Readme.md)  
- [Postgres](https://github.com/ricardodarocha/sqlxpg)  
---

Eu tenho um interesse especial por **Rust!** Este material come√ßou a ser criado para atender ao meu objetivo pessoal de aprender Rust.    
Com o passar do tempo, eu fui percebendo que isso poderia ajudar outras pessoas. Desde ent√£o, eu tenho me esfor√ßado para deixar tudo organizado.

Eu criei o formul√°rio abaixo para examinar os interesses da comunidade.  
Por favor, responda a algumas perguntas bem rapidinho.
https://forms.gle/g5Y6V3g5ag75qcPg8  

# Introdu√ß√£o

Se voc√™ n√£o tem conhecimento de qualquer linguagem de programa√ß√£o, √© recomendado aprender os fundamentos primeiro.   
Aprenda **Python** ou **C** para compreender como as linguagens de programa√ß√£o funcionam.  
**Rust** √© uma linguagem excelente, mas possui v√°rios recursos avan√ßados, e n√£o √© recomed√°vel que voc√™ comece por ela. √â recomend√°vel que voc√™ aprenda **Rust** como segunda linguagem at√© se tornar experiente.  

Veja minha [trilha de python](https://github.com/ricardodarocha/Python)

Voc√™ pode facilmente aprender **Rust** na internet, lendo o [Livro de Rust Oficial](https://livro.rustbr.org/), acessando a [Documenta√ß√£o](https://www.rust-lang.org/pt-BR/). H√° muitos cursos na internet mas o que eu recomendo √© voc√™ fazer parte da comunidade de desenvolvedores. Cadastre-se em f√≥runs e grupos colaborativos, monte um reposit√≥rio e compartilhe com os colegas. E claro, se inscreva nos canais de Rust no Brasil e no Exterior e fique por dentro de tudo que acontece neste universo maravilhoso do Rust.

Para exercitar o que voc√™ vai aprender, primeiro configure um ambiente. 
[Diversas formas de configurar um ambiente Rust](https://www.rust-lang.org/pt-BR/tools/install)

ou brinque no [Rust Playground](https://play.rust-lang.org/) antes de configurar um ambiente local üé†

# Primeiro exerc√≠cio

A forma mais comum de aprender uma linguagem √© come√ßar pelo exemplo _Ol√° mundo_.  

```Rust
fn main() {
    println!("Ol√°, mundo!");
}
```
[tente agora on-line!](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=58b8666302b1dfb3863d0de5e17286ee)

H√° algumas varia√ß√µes deste programa que eu explico aqui, com o objetivo de incrementalmente ir aprendendo novos recursos. Vou utilizar coment√°rios no c√≥digo para explicar. Veja o tutorial sobre [Como comentar c√≥digos Rust](https://github.com/ricardodarocha/Rust/edit/main/Documentando.md).

```Rust
// Disponibilizando diferentes vers√µes para o seu usu√°rio
const VERSION: &'static str = env!("CARGO_PKG_VERSION");

fn main() {
    // neste exemplo, al√©m de aprender a exibir a vers√£o voc√™ tamb√©m aprendeu como formatar valores na mensagem
    println!("Ol√°, mundo! \nEsta √© a vers√£o {}", VERSION);
}
```

# ü¶Ä Dica

o padr√£o **match** √© um dos recursos mais importantes da linguagem Rust

```Rust
let x: i32 = 1;

match x {
  1 => println!("um"),
  2 => println!("dois"),
  3 => println!("tr√™s"),
  - => println!("outro qualquer"),
}
```

[match](https://github.com/ricardodarocha/Rust/new/main/general/correspondencia.rs)  

### m√≥dulos de estudo

[parte 1](#parte-i)  
[parte 2](#parte-ii)  
[parte 3](#parte-iii)  

### √çndice remissivo

# A

Actix  
[Ambiente, configurando](https://www.rust-lang.org/pt-BR/tools/install)  
Ambiente, vari√°veis de (ver env)  
Argumentos, Args  
[Api](https://github.com/ricardodarocha/Rust/blob/main/3_api/Readme.md)  
[Arquivos](#ler-arquivos)  
[Arquitetura](https://github.com/ricardodarocha/Rust/tree/main/arquitetura)  
Aplicativos de Linha de Comando (ver CLI)  
Aplicativos Desktop (ver Desktop)
Aplicativos Web (ver Web)  
Arduino  
ASM  
Atributos (ver Models)  


# B

[Banco de Dados](#trabalhando-com-bancos-de-dados)  
BI  
Bin√°rios, Bin  
Box  

# C

[Cargo](#cargo)  
[Cargo.toml](#cargotoml)  
[Chat](https://github.com/ricardodarocha/rust-chat)   
CLAP  
[Configura√ß√µes do usu√°rio](#ler-um-arquivo-de-configura√ß√µes-env-ini-xml-json)  
[CLI](#criando-uma-aplica√ß√£o-simples-de-linha-de-comando-cli)  
Cores  
CSV  
 
# D

Dashboard  
DDD  
[Debug](#debug)  
[Default](https://github.com/ricardodarocha/Rust/blob/main/general/default.md)  
[Display](https://github.com/ricardodarocha/Rust/blob/main/general/display.md)  
[Design Patterns](https://github.com/ricardodarocha/Rust/tree/main/DesignPattern)  
[Derive](#derive)  
Desktop  
Documenta√ß√£o, Doc    
DOD  

# E

E-mail  
Entidades (ver Models)  
Enumerados, Enum 
env, .env    
Erros  
Estat√≠stica  
Estruturas de Dados (ver Struct)  

# F

Firebird  

# G

Games (ver Jogos)  
Gr√°ficos  
Grafos  
GUI  

# H

Hello world  
HTML  

# I
Imagens 
[Impl Struct](#impl-struct)  
[Impl Trait](#impl-trait)  
[Ini, \*.ini](#ler-um-arquivo-ini)  
IP  
Internet  
Instaladores  

# J

Jogos  
[Json](#lendo-json)  

# L

Linguagem Ub√≠qua  
Log  

# M

Macros  
Matrizes  
[Models](https://github.com/ricardodarocha/Rust/blob/main/Modelos.md), [Modelos](https://github.com/ricardodarocha/Rust/blob/main/Modelos.md)  
M√≥dulos  

# P

Par√¢metros (ver args)  
Playground  
POO  
Postgres  

# R

Result  
Return  

# S

SQL  
[Struct](#struct)  
[Strings](#string)  

# T

Tauri  
Testes
Texto  
Trait ver [Impl Trait](#impl-trait)  
Tipos  
Tuplas  

# V

Vari√°veis
Vari√°veis de ambiente (ver env)  
Vetores  
Vue.js  

# X  

Xadrez  
XML  

üöß Nesta se√ß√£o eu organizo os conte√∫dos por ordem alfab√©tica. Se preferir uma sequ√™ncia de estudos acompanhe o tutorial a seguir.

# Parte I  

A sequ√™ncia de estudo que eu tenho aprimorado para voc√™ que est√° come√ßando do zero √© a seguinte. E eu vou tentar explicar a raz√£o disso:

## Cargo  

### Lista de comandos do compilador

```shell
cargo check #verifica se todos os pacotes est√£o instalados
cargo build #compila o bin√°rio DEBUG
cargo run #roda o bin√°rio DEBUG
cargo clippy #verifica a qualidade sem√¢ntica do algoritmo 
cargo run --release #roda o bin√°rio RELEASE
```
## Cargo.toml

### Alterando as informa√ß√µes de propriedade intelectual

Acesse o cargo.toml e edite os atributos da aplica√ß√£o com as suas informa√ß√µes

```
description ‚Äî Uma descri√ß√£o do programa  
documentation ‚Äî O site onde est√° publicado o pacote rustdoc.rs  
readme ‚Äî Um arquivo Markdown local sobre a sua aplica√ß√£o  
homepage ‚Äî O site da aplica√ß√£o  
repository ‚Äî O reposit√≥rio Github onde est√° publicado o c√≥digo fonte  
license ‚Äî Tipo de licen√ßa  
license-file ‚Äî Os termos da licen√ßa (txt)  
keywords ‚Äî Palavras chave do projeto  
categories ‚Äî Categoria do pacote  
```

[Lista completa de atributos](https://doc.rust-lang.org/cargo/reference/manifest.html)  

## Ler um arquivo de configura√ß√µes (.env .ini .xml .json)

Para gerenciar as configura√ß√µes do usu√°rio escolha uma extens√£o de arquivo
H√° libs espec√≠ficas para cada formato de arquivo, que eu vou mostrar a seguir

### Informa√ß√µes do bin√°rio

O arquivo **cargo.toml** possui informa√ß√µes b√°sicas do bin√°rio

_cargo.toml_
```Rust
[package]
name = "my_package"
version = "0.0.1"
repository = "https://github.com/rust-lang/my-package/"
license = "MIT OR Apache-2.0"
authors = "Ricardo da Rocha"

[dependencies]
```

Acesse estas informa√ß√µes utilizando constantes est√°ticas  

_main.rs_
```Rust
const VERSION: &'static str = env!("CARGO_PKG_VERSION");
const AUTHORS: &'static str = env!("CARGO_PKG_AUTHORS");

fn main() {
  println!("Hello, world! \nThis is version {} \nThanks to {}", VERSION, AUTHORS);
  }
```

### Ler um arquivo ini

[doc](https://github.com/mexili/ini-rs)


### .env vari√°veis de ambiente

Acesse as vari√°veis de ambiente, ou configure o ambiente utilizando um arquivo **.env**  
 
src/.env
```Rust
/// ```ini
/// user_name=admin
/// ```
use dotenv;
dotenv().expect(".env file not found");
println!("KEY", env::var("user_name").unwrap());
env::set_var("password", "unbush84likely8Fdetail42");
```

### passando par√¢metros para a aplica√ß√£o com args()

Ao executar uma aplica√ß√£o pela linha de comandos, voc√™ pode passar par√¢metros para ela
```Shell
c:\App> olamundo.exe ricardo
```

Voc√™ pode facilmente acessar estes par√¢metros atrav√©s do comando `args()`

```Rust
use std::env;
fn main() {
let args: Vec<_> = env::args().collect();
let name = match args.get(1) {
  Some(value) =>  value,
  None => "Mundo"
    };
println!("Ol√° {}!", name)
}
```

## Ler arquivos 

> üß° _Veja esse hack_ [Carregar o conte√∫do de um arquivo para uma string](#carregar-arquivo-em-string)

Da mesma forma que criamos arquivos, √© necess√°rio ler os dados gravados.

H√° duas formas principais de ler estes arquivos, que eu divido em 

  [Ler um arquivo simples]() A maneir mais pr√°tica mas nem sempre resolve.  
  [Ler um arquivo grande no formato de stream]() Esta maneira poderoso permite gerenciar o uso de mem√≥ria e ler arquivos gigantes. 
  
Veja este exemplo b√°sico

```Rust
    let mut file = File::open("mensagem.txt")?;
    let mut conteudo = String::new();
    file.read_to_string(&mut conteudo)?;
    assert_eq!(conteudo, "Hello, world!");
```

### Carregar arquivo em string

```Rust
use std::fs;
use std::path::Path;

let conteudo = fs::read_to_string(Path::new("./Sample.txt") );
match conteudo {
  some(text) => print!(text),
  None => print!("N√£o encontrado")
}
```

## Salvar um arquivo localmente

Ao interagir com o seu programa o usu√°rio o alimenta com dados. Muitas vezes √© conveniente armazenar estes dados para serem recuperados no futuro, mesmo quando o programa √© fechado e ap√≥s abr√≠-lo novamente, o usu√°rio pode precisar reutilizar estes dados ou compartilh√°-los com outros dispositivos por exemplo. Neste exemplo eu mostro como salvar dados localmente ou em rede.

Vamos continuar nosso exemplo e prepar√°-lo para exportar a mensagem em um arquivo

```Rust
use std::env;
fn main() {
let args: Vec<_> = env::args().collect();
let name = match args.get(1) {
  Some(value) =>  value,
  None => "Mundo"
    };
/// Parab√©ns, voc√™ aprendeu a formatar strings
let mensagem = format!("Ol√° {destinatario}!", destinatario = name)

/// E agora vamos salvar nossa mensagem em um arquivo externo
    let mut file = File::create("mensagem.txt")?;
    file.write_all(men sagem)?;
}
```

# Parte II

# ü¶Ä

Boas pr√°ticas de desenvolvimento e dicas de projeto  

## Refatorando em m√©todos

Em qualquer linguagem de programa√ß√£o √© uma boa pr√°tica manter o c√≥digo limpo, e nunca criar fun√ß√µes muito grandes que tenham v√°rias responsabilidades. Isto pode tornar o c√≥digo confuso. Por isso n√≥s vamos come√ßar a refatorar o nosso c√≥digo para quebr√°-lo em v√°rios m√©todos.

```Rust
use std::env;

fn salvar_no_arquivo(mensagem: String) {
  let mut file = File::create("mensagem.txt")?;
  file.write_all(mensagem)?;
 }

fn main() {

let args: Vec<_> = env::args().collect();
let name = match args.get(1) {
  Some(value) =>  value,
  None => "Mundo"
    };
let mensagem = format!("Ol√° {destinatario}!", destinatario = name)

salvar_no_arquivo(mensagem);
}
```

## Utilizando Linguagem Ub√≠qua

Em primeiro lugar, lendo o c√≥digo acima, vemos que n√£o √© adequado manter blocos de c√≥digo que estejam em n√≠veis diferentes dentro da hierarquia de procedimentos, isto √©, o c√≥digo precisa fazer sentido como um todo par aquem l√™. Isto nos faz um convite relacionado ao idioma, e de agora em diante vamos fazer um esfor√ßo para escrever todo o c√≥digo em portugu√™s. Por isso vamos encapsular todo o comportamento de setup do programa no m√©todo chamado `carregar_parametros`, isto nos permitir√° no futuro utilizar um padr√£o de projetos (_design pattern_) muito interessante chamado **Builder**, que utiliza o conceito de _Fluent Api_. Mas n√£o por enquanto.

```Rust
use std::env;

fn pegar_nome_usuario() -> String {
  let argumentos: Vec<_> = env::args().collect();
  let usuario match argumentos.get(1) {
    Some(valor) =>  valor,
    None => "Mundo"
    };
   return usuario;
}

fn formatar_mensagem(usuario) -> String {
  format!("Ol√° {destinatario}!", destinatario = usuario)
}

fn salvar_no_arquivo(mensagem: String) {
  let mut file = File::create("mensagem.txt")?;
  file.write_all(mensagem)?;
 }

fn main() {
let usuario = pegar_nome_usuario();
let mensagem = formatar_mensagem(usuario);
salvar_no_arquivo(mensagem);
}
```
A linguagem ub√≠qua √© um conceito do DDD que prega ao desenvolvedor utilizar aspectos da l√≠ngua falada ao escrever seu c√≥digo, isto √©, deve-se utilizar um formato de narrativa que se aproxime da l√≠ngua dos usu√°rios finais, utilizando inclusive as mesmas palavras que ele utiliza para descrever aquela rotina. Veja que ao utilizar esta t√©cnica o c√≥digo fica mais fluido, e mais simples de ler, um dos preceitos do c√≥digo limpo.

## Outras li√ß√µes da linguagem com este exemplo b√°sico

Em Rust voc√™ n√£o √© obrigado a utilizar **return**
Ao deixar o valor sem ponto e v√≠rgula na √∫ltima linha de uma fun√ß√£o ele ser√° retornando automaticamente

```Rust
fn pegar_nome_usuario() -> String {
  let args: Vec<_> = env::args().collect();
  let name match args.get(1) {
    Some(value) =>  value,
    None => "Mundo"
    };
   name
}
```

Isto dispensa o uso da vari√°vel name

```Rust
fn pegar_nome_usuario() -> String {
  let args: Vec<_> = env::args().collect();
  match args.get(1) {
    Some(value) =>  value,
    None => "Mundo"
    }
}
```

## Criar aplicativos de Console ou de Linha de Comando CLI

Eu estou desenvolvendo um tutorial mais completo sobre CLI no repo [cli with rust](?)üöß   
No entanto aqui eu vou dar uma breve introdu√ß√£o:

## Criando uma aplica√ß√£o simples de linha de comando (CLI) 

Um aplicativo bin√°rio compilado pelo Rust pode ser facilmente integrado √† Interface de Linha de comando de qualquer terminal, seja Linux, Windows ou Plataformas Embarcadas. Voc√™ pode chamar `curl aplicativo.exe` e ele ser√° executado. Mas vamos ver o que podemos fazer para torn√°-lo mais interativo.

A primeira coisa √© trabalhar com argumentos, ou par√¢metros, como vimos no tutorial anterior.
Outra forma √© coletar inputs do usu√°rio, enquanto o programa est√° em execu√ß√£o.

```
fn pegar_nome_usuario() -> String {
  let args: Vec<_> = env::args().collect();
  match args.get(1) {
    Some(value) =>  value,
    None => {
      use std::io::{stdin};
      let mut usuario=String::new();
      print!("Digite seu nome: ");
      let _=stdout().flush();
      stdin().read_line(&mut usuario).wnrap_or("Mundo");
      usuario
      }
    }
}
```
Aprenda o estado da arte com [CLAP](https://docs.rs/clap/2.33.0/clap/)

## Criando interfaces mais amig√°veis e melhores

üöß Se voc√™ quer come√ßar logo veja meu tutorial de [Interfaces Amig√°veis com Rust]()

Aqui n√≥s experimentamos algums recursos b√°sicos de interface. Mesmo utilizando CLI √© poss√≠vel criar boas interfaces. Em seguida avan√ßo um pouco mais criando interfaces "bonitas" com TUI que s√£o interfaces visuais usando ASCII (exclusivo para terminais e aplica√ß√µes de linhas de comando).

Se pretende criar interfaces mais avan√ßadas como UI do Sistema operacional como Janelas do Windows, componentes Nativos eu tamb√©m tenho este estudo. [Interfaces Nativas com Rust]()

Tamb√©m estou desenvolvendo este material sobre o Estado da Arte das Interfaces com Rust e componentes Web com [Interfaces com Rust - Estado da Arte]()

Se voc√™ tem interesse por games d√™ uma olhada nestes [Experimentos com Rust - Games]()

# Parte III

## Tipos

[Tipos primitivos](https://doc.rust-lang.org/rust-by-example/primitives.html)  
[Tipos customizados](https://doc.rust-lang.org/rust-by-example/custom_types.html)  
[Strings](https://doc.rust-lang.org/rust-by-example/conversion/string.html)  

# Colet√¢neas

Nesta s√©rie de colet√¢neas eu vou exibir exemplos mais pr√°ticos poss√≠veis. Por conta disso, eu vou poupar entrar em detalhes.

## Envir um e-mail 

```Rust
use lettre::transport::smtp::authentication::Credentials;
use lettre::{Message, SmtpTransport, Transport};

fn main()
{
    let email = Message::builder()
        .from("sender@...".parse().unwrap())
        .to("dest@...".parse().unwrap())
        .subject("Hello From Rust")
        .body(String::from("This is an automatic e-mail, please ignore!"))
        .unwrap();

    let creds = Credentials::new(
        "sender@...".to_string(),
        "password".to_string()
    );

    // Open a remote connection to gmail
    let mailer = SmtpTransport::relay("smtp.gmail.com")
        .unwrap()
        .credentials(creds)
        .build();

    // Send the email
    match mailer.send(&email) {
        Ok(_) => println!("Email sent successfully!"),
        Err(e) => panic!("Could not send email: {:?}", e),
    }
}
```

## Lendo arquivos CSV 

Consulte o tutorial completo da [https://rust-lang-nursery.github.io/rust-cookbook/encoding/csv.html](documenta√ß√£o)
```Rust
let mut rdr = csv::ReaderBuilder::new()
        .has_headers(false)
        .from_reader(io::stdin());
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
```

## Lendo JSON 

usando Serde
```Rust
fn main() {
    let the_file = r#"{
        "FirstName": "John",
        "LastName": "Doe",
        "Age": 43,
        "Address": {
            "Street": "Downing Street 10",
            "City": "London",
            "Country": "Great Britain"
        },
        "PhoneNumbers": [
            "+44 1234567",
            "+44 2345678"
        ]
    }"#;

    let json: serde_json::Value =
        serde_json::from_str(the_file).expect("JSON was not well-formatted");
}
```
Cargo.toml:
```
[dependencies]
serde = { version = "1.0.104", features = ["derive"] }
serde_json = "1.0.48"
```

## Gerando uma senha

```Rust
//Create random passwords from a set of alphanumeric characters
//rand-badge cat-os-badge

//Randomly generates a string of given length ASCII characters in the range A-Z, a-z, 0-9, with Alphanumeric sample.


use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;

fn main() {
    let rand_string: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(30)
        .map(char::from)
        .collect();

    println!("{}", rand_string);
}
//Create random passwords from a set of user-defined characters
//rand-badge cat-os-badge

//Randomly generates a string of given length ASCII characters with custom user-defined bytestring, with gen_range.


fn main() {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                            abcdefghijklmnopqrstuvwxyz\
                            0123456789)(*&^%$#@!~";
    const PASSWORD_LEN: usize = 30;
    let mut rng = rand::thread_rng();

    let password: String = (0..PASSWORD_LEN)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect();

    println!("{:?}", password);
}
```
[fonte](https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html)   

## Trabalhando com Bancos de dados

√â recomendado utilizar a biblioteca [Diesel](https://diesel.rs/guides/getting-started) ou [sqlx]()  
Consulte tamb√©m [Postgresl](https://docs.rs/postgres/0.15.2/postgres/)
Consulte tamb√©m [SQLite](https://docs.rs/sqlite/latest/sqlite/)
Consulte tamb√©m [Firebird](https://github.com/fernandobatels/rsfbclient)  
```Rust
```

Nesta se√ß√£o eu dedico uma parte especial ao SQLite.
Em seguida eu recomendo voc√™ experimentar um banco de dados Profissional que suporta grande volume de dados como Postgresql
[Trabalhando com Banco de Dados]

Neste diret√≥rio eu re√∫no um estudo completo de SQL com Rust, incluindo discutindo alguns fundamentos de SQL [SQL completo com Rust]
# Log

In this example I explore the funcionalities of crate LOG, and how to show into console the status of server.
It's a continuation of example 3_api

## Criando Um Chat

[Acesse o Link](https://github.com/ricardodarocha/rust-chat-old)

---

## Box  

Crie refer√™ncias encadeadas com Box  
Veja este exemplo de √°rvore geneal√≥gica  
```Rust
#[derive(Debug)]
struct MinhaArvore {
    nome: String,
    ramos: Option<Box<MinhaArvore>>,
}

fn main() {
    let galileu = MinhaArvore {
        nome: "Galileu",
        ramos: Some(Box::new(MinhaArvore{
            nome: "Newton",
            ramos: Some(Box::new(MinhaArvore){
                nome: "Einstein",
                ramos: Some(Box::new(MinhaArvore))
                })
            })
        )
    }
}

println!("{#?}", galileu);
```

## Debug  

Debug pode se referir a 
[target de compila√ß√£o]()   
[derive annotation]()  
[processo de depura√ß√£o]()  

### target debug

H√° dois tipos de bin√°rios *DEBUG* e *RELEASE*
Ao compilar um projeto com `cargo build` √© criado um bin√°rio na pasta `\target\debug\`. Este bin√°rio normalmente √© um pouco maior do que uma vers√£o release  
A vers√£o release √© utilizada para distribui√ß√£o do seu aplicativo, e a vers√£o debug √© utilizada para testes  
A vers√£o debug normalmente cont√©m mais informa√ß√µes importantes para o desenvolvedor testar e procurar por BUGS    
Para compilar uma vers√£o debug basta rodar o comando `cargo run` e a vers√£o relase `cargo run --release`

```shell
cargo run 
// \target\debug\projeto.exe

cargo run --release
// \target\release\projeto.exe
```

## derive

Esta √© mais uma macro do RUST que nos auxilia a gerar instru√ß√µes sem a necessidade de escrever c√≥digo  Rust ir√° gerar automaticamente v√°rias linhas de c√≥digo quando utilizarmos derive  
H√° algumas anota√ß√µes espec√≠ficas com objetivos espec√≠ficos  
Veja na tabela a seguir alguns exemplos de derive em estruturas de dados [Struct](#struct)  

||||
|-|-|-|
|`#[derive(Debug)]`|permite imprimir informa√ß√µes em runtime|`println!("{#?}", objeto)`|
|`#[derive(Default)]`|permite atribuir valores default ao criar uma nova inst√¢ncia|`Objeto::defaul()`|
|`#[derive(Default)]`|permite representar o objeto em string|`Objeto::to_str()`|
|`#[derive(Serialize)]`|permite converter em Json|``|
|`#[derive(Deserialize)]`|permite ler a partir de um Json|``|
|`#[derive(Clone)]`|permite criar c√≥pias do objeto|`obj2 = obj1.clone()`|

```

```

# Struct

Estruturas de dados representam objetos, embora n√£o seja exatamente uma linguagem POO √© poss√≠vel criar objetos com Rust utilizando Structs. A diferen√ßa √© que RUST n√£o possui suporte a heran√ßa. No entanto v√°rios problemas de heran√ßa podem ser resolvidos utilizando Composition  

```Rust
struct MeuObjeto {
  id: Uuid,
  nome: String,
  quantidade: i32, //-‚ôæ ..2^32
  celulas: u16, //0..255
  ativo: bool,
  arquivo: Path
}
```
Observe que Rust possui v√°rios tipos primitivos mas tamb√©m possui tipos enriquecidos, com Path, Filename, Date etc
Para isso √© necess√°rio importar crates externas

```Rust
use std::path::Path;
use uuid::Uuid;
```

## Advanced Struct - Estruturas avan√ßadas

Estruturas normalmente representam dados, no entanto √© poss√≠vel adicionar m√©todos de comportamentos aos objetos utilizando impl

## Impl Struct

Implementar comportamento em estruturas

```Rust
struct MeuObjeto {
  id: Uuid,
  nome: String,}
  
  impl MeuObjeto {
  
  fn New() -> &Self {
    MeuObjeto {
      id: Uuid::new_v4(),
      nome: "An√¥nimo".to_own(),
    }
  }
  }
``` 

## Impl Trait

Implementando contratos em estruturas

Al√©m de implementar m√©todos √© poss√≠vel implementar contratos   
Contratos s√£o similares √† interfaces. Com a diferen√ßa de que interfaces podem ou n√£o implementar heran√ßas e possuem caracter√≠sticas inerentes √† POO, traits possuem particularidades que deixam-no mais poderosos.

por exemplo vamos implementar um contrato Admin na nossa estrutura

```Rust
pub trait Admin {
   fn login(&self) -> bool {
     false
   };
}
```
Veja que tratis possuem uma implementa√ß√£o padr√£o, ou seja n√£o exige abstra√ß√£o em cen√°rios onde n√£o √© necess√°rio

```Rust
impl Admin for MeuObjeto {
  fn login(&self) -> bool {
     return nome == "Admin"
   };
}

```

Neste exemplo o objeto que possuir o nome "Admin" ir√° retornar Login=True

```Rust

let user1 = MeuObjeto::new();
let user2 = MeuObjeto::new(); 
let user2.nome = "Admin".to_own();

print!("user 1 can login {}", user1.login()) //false
print!("user 2 can login {}", user2.login()) //true
}
```

# Sumary by Subject

The examples by subject are in \General Folder

## Variables

## Types

## Modules

```Rust
-main.rs-
mod routes; //A file with name routes.rs

---
-routes.rs-
#[get("/")]
pub async fn hello() -> impl Responder {
    HttpResponse::Ok().body("Hello world!")
}

#[post("/echo")]
pub async fn echo(req_body: String) -> impl Responder {
    HttpResponse::Ok().body(req_body)
}
```

## Loop expressions

```Rust
for x in 1..11{ // 11 is not inclusive
      if x%2==0 {println!("{x} is even")}
      if x==5 {
         continue;
      println("{x}")
      
      if x==5 {
         break x //If is a function, returns x
         }
      }
```

Loops in details [](https://github.com/ricardodarocha/Rust/blob/main/general/loopExpressions)

## Error Handling

```Rust
fn exit(x: i32) {
    if x == 0 {
        panic!("we got a 0");
    }
    println!("things are fine")
}
```

Check [erro handling](https://github.com/ricardodarocha/Rust/blob/main/general/errorhandling.md) studies

## Writing tests and documentations

See this Topic [here](https://github.com/ricardodarocha/Rust/blob/main/general/tests_and_docs)

## env

Environments can be controlled using **Argument Parameters** and **Environment Variables**

### Reading Args

```Rust
/// In this example we intercept first argunt sent by the user when calling the executable
/// ```shell
/// cargo run --parameter
/// ```
use std::env;
mod routes;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let args: Vec<_> = env::args().collect();
    let port = &args[1];
```

###  TUI

This is how we can create amazing TUI Text User Interfaces with Rust.

[blue TUI](https://lib.rs/crates/cursive)
[term-table](https://lib.rs/crates/term-table)

A lot of other [TUI libraries](https://lib.rs/command-line-interface)

# Api 

Este √© um guia para criar [Api com Rust](https://github.com/ricardodarocha/newapi)  

Para criar apis avan√ßadas com acesso ao banco de dados acesse
[Api Postgres](https://github.com/ricardodarocha/sqlxpg)

## Api b√°sica

Neste exemplo eu mostro como criar uma API do zero  
Clone o reposit√≥rio e altere routes.rs

Comece com o arquivo `main.rs`

```Rust
HttpServer::new(|| {
        App::new()
            .service(routes::hello)
            .service(routes::echo)
            .route("/hey", web::get().to(routes::manual_hello))
    })
    .bind(("127.0.0.1", port))?
    .run()
    .await
```

Neste exemplo eu recomendo voc√™ come√ßar com dois arquivos, ou seja
a regra de neg√≥cios principal fica no main.rs, onde voc√™ exp√µe o servidor e suas configura√ß√µes b√°sicas, como a porta.
As rotas voc√™ deve deixar no arquivo routes.rs.
Eu recomendo criar as rotas em um arquivo separado porque um projeto de API pode se tornar grande com o tempo, e mesmo para projetos pequenos, voc√™ criar uma melhora separa√ß√£o das responsabilidades.

Veja [como criar m√≥dulos](https://github.com/ricardodarocha/Rust/edit/main/README.md#Modules)

# Arquiteturas com RUST

Nesta se√ß√£o eu re√∫no meus estudos mais recentes sobre Arquiteturas com Rust, inclusive comparando com outras linguagens e discutindo as vantanges e desvantanges de cada um. [link](https://github.com/ricardodarocha/Rust/tree/main/arquitetura)

# Links

**github notebook**(Best Rust curated)[https://github.com/brson/rust-anthology/blob/master/master-list.md]
**video** (Error Handling)[https://www.youtube.com/watch?v=mhw-x5Q_-z0&t=195s]  
(**rust cookbook**)[https://rust-lang-nursery.github.io/rust-cookbook]
https://lib.rs/crates/cursive
